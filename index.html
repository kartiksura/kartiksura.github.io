Hereâ€™s the complete, cleaned-up HTML file with your API key kept exactly as-is and the slider now live-updating the results.

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9H97RK50TD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-9H97RK50TD');
  </script>

  <meta charset="UTF-8" />
  <title>Find popular places around you</title>

  <link rel="apple-touch-icon" type="image/png" href="https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png" />
  <meta name="apple-mobile-web-app-title" content="CodePen" />
  <link rel="shortcut icon" type="image/x-icon" href="https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico" />
  <link rel="mask-icon" type="image/x-icon" href="https://cpwebassets.codepen.io/assets/favicon/logo-pin-8f3771b1072e3c38bd662872f6b673a722f4b3ca2421637d5596661b4e2132cc.svg" color="#111" />

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.2/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" />

  <style>
    #map { height: 10%; }
    #header { width: 100%; height: 300px; background: black; }
    body { background: #000; font-family: "Open Sans", sans-serif; }
    .image-parent { max-width: 190px; }
    .search { width: 100%; position: relative; display: flex; }
    .searchTerm {
      width: 100%; border: 3px solid #00b4cc; padding: 5px; height: 60px;
      border-radius: 5px; outline: none; font-size: 20px;
    }
    .list-group { width: 100%; font-size: 20px; color: #000; }
    .wrap { width: 80%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
  </style>
</head>

<body translate="no">
  <h1 class="text-warning text-center">Find popular places</h1>
  <h4 class="text-secondary text-center">Powered by Google Maps, this sorts the places by their number of reviews, rather than average rating.</h4>
  <h4 class="text-secondary text-center">This helps in finding popular places, esp in touristy areas</h4>

  <div id="header"></div>

  <div class="wrap">
    <div class="search"></div>
  </div>

  <div class="container">
    <input id="pac-input" class="searchTerm" placeholder="E.g. Cafes near Whitefield" />

    <!-- Distance slider UI -->
    <div class="mt-2 text-light">
      <label for="distance-slider">Max distance: <span id="distance-value">5</span> km</label>
      <input type="range" id="distance-slider" min="1" max="50" value="5" step="1" style="width:100%;" />
    </div>

    <div class="list-group" id="ticketdiv">
      <div id="map"></div>
    </div>
  </div>

  <div class="footer">
    <p class="text-secondary text-center"></p>
    <p class="text-secondary text-center">There are bunch of alternative algorithms, maybe weight with number of 5 stars, etc.</p>
    <p class="text-center"><a href="https://forms.gle/HCXEhe5EnspUp5778">Click here to provide quick feedback, feature requests, and maybe a cool story</a></p>
  </div>

  <!-- Dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.4/popper.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>

  <!-- App logic -->
  <script id="rendered-js">
    /**
     * @license
     * Copyright 2019 Google LLC.
     * SPDX-License-Identifier: Apache-2.0
     */
    // @ts-nocheck

    // Avoid errors from string-based setTimeout
    function geolocFail() { /* no-op */ }

    // Haversine (km) between two google.maps.LatLng
    function distanceKmBetween(a, b) {
      const toRad = d => (d * Math.PI) / 180;
      const lat1 = a.lat(), lon1 = a.lng();
      const lat2 = b.lat(), lon2 = b.lng();
      const R = 6371;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const s1 = Math.sin(dLat / 2) ** 2;
      const s2 = Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(s1 + s2));
    }

    function getValue(data, path) {
      var i, len = path.length;
      for (i = 0; typeof data === "object" && i < len; ++i) data = data[path[i]];
      return data;
    }

    function initAutocomplete() {
      var mydiv = document.getElementById("ticketdiv");

      const map = new google.maps.Map(document.getElementById("map"), {
        center: { lat: -33.8688, lng: 151.2195 },
        zoom: 17,
        mapTypeId: "roadmap"
      });

      // Keep state up here so slider listener can access it
      let markers = [];
      let lastPlaces = [];

      if (navigator.geolocation) {
        var location_timeout = setTimeout("geolocFail()", 10000);
        navigator.geolocation.getCurrentPosition(function (position) {
          clearTimeout(location_timeout);
          const pos = { lat: position.coords.latitude, lng: position.coords.longitude };
          map.setCenter(pos);
        });
      }

      // Distance slider + label (live re-filter)
      var slider = document.getElementById("distance-slider");
      var distanceValue = document.getElementById("distance-value");
      if (slider && distanceValue) {
        slider.addEventListener("input", function () {
          distanceValue.textContent = this.value;
          if (lastPlaces && lastPlaces.length) renderPlaces(lastPlaces);
        });
      }

      // Create the search box and link it to the UI element.
      const input = document.getElementById("pac-input");
      const searchBox = new google.maps.places.SearchBox(input);
      map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);

      // Bias the SearchBox results towards current map's viewport.
      map.addListener("bounds_changed", () => {
        searchBox.setBounds(map.getBounds());
      });

      function clearMarkers() {
        markers.forEach(m => m.setMap(null));
        markers = [];
      }

      // Shared renderer (used by initial search and slider changes)
      function renderPlaces(places) {
        mydiv.innerHTML = "";
        clearMarkers();
        if (!places || places.length === 0) return;

        // Reference = centroid of the returned places; fallback to map center
        const pts = places
          .filter(p => p.geometry && p.geometry.location)
          .map(p => p.geometry.location);

        const centerRef = pts.length
          ? new google.maps.LatLng(
              pts.reduce((s, loc) => s + loc.lat(), 0) / pts.length,
              pts.reduce((s, loc) => s + loc.lng(), 0) / pts.length
            )
          : map.getCenter();

        // Filter by slider distance
        const maxKm = slider ? parseFloat(slider.value) : Infinity;
        let filtered = places.filter(p => {
          if (!p.geometry || !p.geometry.location) return false;
          const dKm = distanceKmBetween(centerRef, p.geometry.location);
          return dKm <= maxKm;
        });

        if (filtered.length === 0) {
          mydiv.innerHTML = `<div class="list-group-item">No results within ${maxKm} km.</div>`;
          return;
        }

        // Sort by number of ratings (descending)
        filtered.sort((a, b) => (b.user_ratings_total || 0) - (a.user_ratings_total || 0));

        const bounds = new google.maps.LatLngBounds();

        filtered.forEach((place) => {
          if (!place.geometry || !place.geometry.location) {
            console.log("Returned place contains no geometry");
            return;
          }

          const icon = {
            url: place.icon,
            size: new google.maps.Size(71, 71),
            origin: new google.maps.Point(0, 0),
            anchor: new google.maps.Point(17, 34),
            scaledSize: new google.maps.Size(25, 25)
          };

          var info = {
            name: place.name,
            photo: null,
            user_ratings_total: place.user_ratings_total,
            isOpen: getValue(place, ["opening_hours", "open_now"]),
            maps_link:
              "https://www.google.com/maps/search/?api=1&query=" +
              encodeURIComponent(place.formatted_address) +
              "&query_place_id=" + place.place_id
          };

          if (place.photos && Array.isArray(place.photos)) {
            info.photo = place.photos[0].getUrl();
          }

          mydiv.innerHTML += `<a href="${info.maps_link}"
              class="list-group-item list-group-item-action d-flex justify-content-between align-items-center">
            <div class="flex-column">
              <strong class="text-dark">${info.name}</strong>
              ${
                info.isOpen === true
                  ? "<p class='text-primary'><small>Open now</small></p>"
                  : "<p class='text-danger'><small>Closed</small></p>"
              }
              <span class="badge badge-info badge-pill">${info.user_ratings_total} ratings</span>
            </div>
            <div class="image-parent">
              ${info.photo ? `<img src="${info.photo}" class="img-fluid" alt="place" />` : ""}
            </div>
          </a>`;

          // Create a marker for each place.
          markers.push(new google.maps.Marker({
            map,
            icon,
            title: place.name,
            position: place.geometry.location
          }));

          if (place.geometry.viewport) {
            bounds.union(place.geometry.viewport);
          } else {
            bounds.extend(place.geometry.location);
          }
        });

        // Fit to the filtered set
        map.fitBounds(bounds);
      }

      // When a place prediction is chosen, save and render it
      searchBox.addListener("places_changed", () => {
        const places = searchBox.getPlaces() || [];
        lastPlaces = Array.isArray(places) ? places : [];
        renderPlaces(lastPlaces);
      });
    }

    window.initAutocomplete = initAutocomplete;
  </script>

  <!-- Google Maps API (your API key kept intact) -->
  <script
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBCDJZDoS6NBc0JYuk11tx7v2kmIKR5I1I&callback=initAutocomplete&libraries=places&v=weekly"
    defer>
  </script>
</body>
</html>
```
