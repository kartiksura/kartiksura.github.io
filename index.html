<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9H97RK50TD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-9H97RK50TD');
  </script>

  <meta charset="UTF-8" />
  <title>Find popular places around you</title>

  <link rel="apple-touch-icon" type="image/png" href="https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png" />
  <meta name="apple-mobile-web-app-title" content="CodePen" />
  <link rel="shortcut icon" type="image/x-icon" href="https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico" />
  <link rel="mask-icon" type="image/x-icon" href="https://cpwebassets.codepen.io/assets/favicon/logo-pin-8f3771b1072e3c38bd662872f6b673a722f4b3ca2421637d5596661b4e2132cc.svg" color="#111" />

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.2/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" />

  <style>
    body { background: #000; font-family: "Open Sans", sans-serif; }
    #header { width: 100%; height: 200px; background: #000; }
    .searchTerm {
      width: 100%; border: 3px solid #00b4cc; padding: 5px; height: 60px;
      border-radius: 5px; outline: none; font-size: 20px;
    }
    #map { height: 260px; border-radius: 6px; }
    .image-parent { max-width: 190px; }
    .list-group { font-size: 18px; color: #000; }
    .hint { font-size: 12px; opacity: 0.75; }

    /* --- Thicker, easier-to-grab slider --- */
    #distance-slider {
      -webkit-appearance: none;
      width: 100%;
      height: 16px;
      background: transparent;
      margin: 6px 0;
      cursor: pointer;
      touch-action: pan-y;
    }
    #distance-slider:focus { outline: none; }

    /* WebKit */
    #distance-slider::-webkit-slider-runnable-track {
      height: 16px; background: #1b1b1b; border-radius: 10px; border: 1px solid #00b4cc;
    }
    #distance-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      margin-top: -6px;
      width: 28px; height: 28px; border-radius: 50%;
      background: #00b4cc; border: 2px solid #66e0ef; box-shadow: 0 0 0 3px rgba(0,180,204,0.15);
    }
    #distance-slider:active::-webkit-slider-thumb { transform: scale(1.05); }

    /* Firefox */
    #distance-slider::-moz-range-track {
      height: 16px; background: #1b1b1b; border-radius: 10px; border: 1px solid #00b4cc;
    }
    #distance-slider::-moz-range-thumb {
      width: 28px; height: 28px; border-radius: 50%;
      background: #00b4cc; border: 2px solid #66e0ef; box-shadow: 0 0 0 3px rgba(0,180,204,0.15);
    }

    /* Old Edge / IE */
    #distance-slider::-ms-track { height: 16px; background: transparent; border-color: transparent; color: transparent; }
    #distance-slider::-ms-fill-lower, #distance-slider::-ms-fill-upper {
      height: 16px; background: #1b1b1b; border: 1px solid #00b4cc; border-radius: 10px;
    }
    #distance-slider::-ms-thumb {
      width: 28px; height: 28px; border-radius: 50%; background: #00b4cc; border: 2px solid #66e0ef;
    }
  </style>
</head>

<body translate="no">
  <h1 class="text-warning text-center">Find popular places</h1>
  <h4 class="text-secondary text-center">Filter by distance and choose Top or New places.</h4>

  <div id="header"></div>

  <div class="container">
    <!-- DEFAULT FOCUS -->
    <input id="pac-input" class="searchTerm" placeholder="E.g. Cafes near Whitefield" autofocus />

    <!-- Sorting mode toggle -->
    <div class="mt-2 text-light">
      <div id="mode-container" class="btn-group btn-group-toggle" data-toggle="buttons" role="group" aria-label="Sort mode">
        <label class="btn btn-sm btn-outline-info active" title="Sort by number of ratings">
          <input type="radio" name="modeOptions" id="mode-top" value="top" autocomplete="off" checked> Top places
        </label>
        <label class="btn btn-sm btn-outline-info" title="Newest places first">
          <input type="radio" name="modeOptions" id="mode-new" value="new" autocomplete="off"> New places
        </label>
      </div>
      <div class="hint mt-1">Top = by number of ratings. New = earliest review date (fallback: unknown).</div>
    </div>

    <!-- Distance slider UI -->
    <div class="mt-2 text-light">
      <label for="distance-slider">Max distance: <span id="distance-value">5</span> km</label>
      <input type="range" id="distance-slider" min="1" max="50" value="5" step="1" />
      <div class="hint mt-1">Distance is measured from your location (if allowed) or the current map center.</div>
    </div>

    <!-- Map + Results -->
    <div class="mt-3">
      <div id="map" class="mb-3"></div>
      <div id="results" class="list-group"></div>
    </div>

    <div class="footer mt-3">
      <p class="text-secondary text-center">There are alternative algorithms (e.g., weight by 5â˜… count).</p>
      <p class="text-center"><a href="https://forms.gle/HCXEhe5EnspUp5778">Share feedback / feature requests</a></p>
    </div>
  </div>

  <!-- Dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.4/popper.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>

  <!-- App logic -->
  <script>
    // @ts-nocheck

    /* Swallow noisy extension error: "A listener indicated an asynchronous response..." */
    window.addEventListener('unhandledrejection', (e) => {
      const msg = String((e && e.reason && e.reason.message) || e.reason || '');
      if (msg.includes('A listener indicated an asynchronous response')) e.preventDefault();
    });

    function geolocFail() { /* no-op */ }
    function getValue(data, path) { for (let i=0;i<path.length && typeof data==="object";i++) data = data[path[i]]; return data; }

    // Fallback distance (km) if geometry lib isn't loaded
    function haversineKm(a, b) {
      const toRad = d => d * Math.PI / 180;
      const lat1 = a.lat(), lon1 = a.lng(), lat2 = b.lat(), lon2 = b.lng();
      const R = 6371, dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
      const s1 = Math.sin(dLat/2)**2;
      const s2 = Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(s1+s2));
    }
    function distanceMeters(origin, loc) {
      if (window.google && google.maps && google.maps.geometry && google.maps.geometry.spherical) {
        return google.maps.geometry.spherical.computeDistanceBetween(origin, loc);
      }
      return haversineKm(origin, loc) * 1000;
    }

    function formatAge(tsMs) {
      if (!tsMs || isNaN(tsMs)) return "unknown";
      const now = Date.now(); let diff = Math.max(0, now - tsMs);
      const day = 86400000, year = 365.25*day, month = 30.44*day;
      const y = Math.floor(diff/year); diff -= y*year;
      const m = Math.floor(diff/month); diff -= m*month;
      const d = Math.floor(diff/day);
      if (y>=1) return `${y} yr${y>1?'s':''}${m?` ${m} mo`:''}`;
      if (m>=1) return `${m} mo${d?` ${d} d`:''}`;
      if (d>=1) return `${d} d`;
      const h = Math.floor(diff/3600000); if (h>=1) return `${h} hr${h>1?'s':''}`;
      const min = Math.floor(diff/60000); if (min>=1) return `${min} min`;
      return "today";
    }

    function initAutocomplete() {
      const resultsEl = document.getElementById("results");
      const input = document.getElementById("pac-input");
      const slider = document.getElementById("distance-slider");
      const distanceValue = document.getElementById("distance-value");
      const modeContainer = document.getElementById("mode-container");

      const map = new google.maps.Map(document.getElementById("map"), {
        center: { lat: -33.8688, lng: 151.2195 }, zoom: 15, mapTypeId: "roadmap"
      });

      // ---- State ----
      let markers = [];
      let lastPlaces = [];
      let origin = map.getCenter();
      const placesService = new google.maps.places.PlacesService(map);

      // Age cache: place_id -> { score, tsMs, source }
      const ageCache = new Map();
      const agePending = new Map();
      let renderSeq = 0; // guard to avoid stale re-renders

      function currentMode() {
        const sel = document.querySelector('input[name="modeOptions"]:checked');
        return sel ? sel.value : "top";
      }

      // Visual distance circle
      const radiusCircle = new google.maps.Circle({
        map, center: origin, radius: parseFloat(slider.value)*1000,
        strokeColor: "#00b4cc", strokeOpacity: 0.8, strokeWeight: 1,
        fillColor: "#00b4cc", fillOpacity: 0.08, clickable: false
      });

      // Geolocation origin
      if (navigator.geolocation) {
        const t = setTimeout(geolocFail, 10000);
        navigator.geolocation.getCurrentPosition(pos => {
          clearTimeout(t);
          origin = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
          map.setCenter(origin);
          radiusCircle.setCenter(origin);
          if (lastPlaces.length) renderPlaces(lastPlaces, {force:false});
        });
      }

      // SearchBox
      const searchBox = new google.maps.places.SearchBox(input);
      map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);

      // Keep focus after Maps moves input into controls
      setTimeout(() => { input.focus(); input.select(); }, 0);
      google.maps.event.addListenerOnce(map, 'idle', () => { input.focus(); input.select(); });

      map.addListener("bounds_changed", () => searchBox.setBounds(map.getBounds()));
      map.addListener("idle", () => {
        origin = map.getCenter();
        radiusCircle.setCenter(origin);
        if (lastPlaces.length) renderPlaces(lastPlaces, {force:false});
      });

      // Distance slider (live updates)
      const onDistanceChanged = () => {
        const km = parseFloat(slider.value);
        distanceValue.textContent = km;
        radiusCircle.setRadius(km*1000);
        if (lastPlaces.length) renderPlaces(lastPlaces, {force:false});
      };
      distanceValue.textContent = slider.value; // initial label
      slider.addEventListener("input", onDistanceChanged);
      slider.addEventListener("change", onDistanceChanged);

      // Mode change (delegated)
      modeContainer.addEventListener("change", e => {
        if (e.target && e.target.name === "modeOptions") renderPlaces(lastPlaces, {force:true});
      });
      modeContainer.addEventListener("click", e => {
        const inputEl = e.target.closest('input[name="modeOptions"]');
        if (inputEl) setTimeout(() => renderPlaces(lastPlaces, {force:true}), 0);
      });

      function clearMarkers() { markers.forEach(m => m.setMap(null)); markers = []; }

      // Safely fetch "newness" meta; never rejects
      function getNewnessMeta(place) {
        const pid = place.place_id;
        if (ageCache.has(pid)) return Promise.resolve(ageCache.get(pid));
        if (agePending.has(pid)) return agePending.get(pid);

        const p = new Promise((resolve) => {
          try {
            placesService.getDetails(
              { placeId: pid, fields: ['reviews','user_ratings_total'] },
              (details, status) => {
                let meta = { score: 0, tsMs: null, source: 'heuristic' };
                try {
                  if (status === google.maps.places.PlacesServiceStatus.OK &&
                      details && Array.isArray(details.reviews) && details.reviews.length) {
                    const times = details.reviews.map(r => r && r.time ? r.time*1000 : 0).filter(n => n>0);
                    if (times.length) {
                      const firstTsMs = Math.min(...times); // earliest review
                      meta = { score: firstTsMs, tsMs: firstTsMs, source: 'review' };
                    }
                  }
                  if (!meta.tsMs) {
                    // no reviews -> unknown age; keep a heuristic score for sorting only
                    meta = { score: Date.now() - (place.user_ratings_total || 0)*86400000, tsMs: null, source: 'heuristic' };
                  }
                } catch (_) {}
                ageCache.set(pid, meta); agePending.delete(pid); resolve(meta);
              }
            );
          } catch (_) {
            const meta = { score: Date.now(), tsMs: null, source: 'heuristic' };
            ageCache.set(pid, meta); agePending.delete(pid); resolve(meta);
          }
        });

        agePending.set(pid, p);
        return p;
      }

      function paintList(list) {
        resultsEl.innerHTML = "";
        const frag = document.createDocumentFragment();

        list.forEach(place => {
          if (!place.geometry || !place.geometry.location) return;

          const meters = distanceMeters(origin, place.geometry.location);
          const distKm = (meters/1000).toFixed(2);
          const pid = place.place_id;
          const meta = ageCache.get(pid);
          const ageText = meta && meta.tsMs ? formatAge(meta.tsMs) : "unknown";
          const sinceText = meta && meta.tsMs ? new Date(meta.tsMs).toLocaleDateString() : "";

          const a = document.createElement("a");
          a.className = "list-group-item list-group-item-action d-flex justify-content-between align-items-center";
          a.href = "https://www.google.com/maps/search/?api=1&query=" +
                   encodeURIComponent(place.formatted_address || place.name) +
                   "&query_place_id=" + place.place_id;

          a.innerHTML = `
            <div class="flex-column">
              <strong class="text-dark">${place.name}</strong>
              ${ getValue(place, ["opening_hours","open_now"]) === true
                  ? "<p class='text-primary mb-1'><small>Open now</small></p>"
                  : "<p class='text-danger mb-1'><small>Closed</small></p>" }
              <span class="badge badge-info badge-pill">${place.user_ratings_total || 0} ratings</span>
              <span class="badge badge-secondary badge-pill ml-2">${distKm} km</span>
              <span class="badge badge-light badge-pill ml-2">age: ${ageText}</span>
              ${ sinceText ? `<span class="badge badge-dark badge-pill ml-2">since ${sinceText}</span>` : "" }
            </div>
            <div class="image-parent">
              ${ place.photos && place.photos[0] ? `<img src="${place.photos[0].getUrl()}" class="img-fluid" alt="place">` : "" }
            </div>
          `;
          frag.appendChild(a);

          // Marker
          const icon = { url: place.icon, size: new google.maps.Size(71,71),
                         origin: new google.maps.Point(0,0), anchor: new google.maps.Point(17,34),
                         scaledSize: new google.maps.Size(25,25) };
          markers.push(new google.maps.Marker({ map, icon, title: place.name, position: place.geometry.location }));
        });

        resultsEl.appendChild(frag);
      }

      async function renderPlaces(places, {force=false} = {}) {
        const mySeq = ++renderSeq;

        resultsEl.innerHTML = "";
        clearMarkers();
        if (!places || !places.length) return;

        const mode = currentMode();
        const maxKm = parseFloat(slider.value);

        let filtered = places.filter(p =>
          p.geometry && p.geometry.location &&
          distanceMeters(origin, p.geometry.location) <= maxKm*1000
        );

        if (!filtered.length) {
          if (mySeq !== renderSeq) return;
          resultsEl.innerHTML = `<div class="list-group-item">No results within ${maxKm} km.</div>`;
          return;
        }

        if (mode === "top") {
          filtered.sort((a,b) => (b.user_ratings_total || 0) - (a.user_ratings_total || 0));
        } else {
          // If metas already exist for all, sort now
          const haveAllMetas = filtered.every(p => ageCache.has(p.place_id));
          if (haveAllMetas) {
            filtered = filtered
              .map(p => ({ p, m: ageCache.get(p.place_id) }))
              .sort((a,b) => (b.m.score - a.m.score))
              .map(x => x.p);
          }
        }

        if (mySeq !== renderSeq) return;
        paintList(filtered);

        // If "new" and some metas missing, fetch then resort & repaint
        if (mode === "new") {
          const toFetch = filtered.filter(p => !ageCache.has(p.place_id));
          if (toFetch.length) {
            try {
              await Promise.all(toFetch.map(p => getNewnessMeta(p)));
              if (mySeq !== renderSeq) return;
              const resorted = filtered
                .map(p => ({ p, m: ageCache.get(p.place_id) }))
                .sort((a,b) => (b.m.score - a.m.score))
                .map(x => x.p);
              if (mySeq !== renderSeq) return;
              paintList(resorted);
            } catch (err) {
              console.warn('Age fetch error (ignored):', err);
            }
          }
        }
      }

      // When a place prediction is chosen
      searchBox.addListener("places_changed", () => {
        const places = searchBox.getPlaces() || [];
        lastPlaces = Array.isArray(places) ? places : [];
        renderPlaces(lastPlaces, {force:true});
      });
    }

    window.initAutocomplete = initAutocomplete;
  </script>

  <!-- Google Maps API (your key unchanged). We request 'geometry' but also have a fallback. -->
  <script
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBCDJZDoS6NBc0JYuk11tx7v2kmIKR5I1I&callback=initAutocomplete&libraries=places,geometry&v=weekly"
    defer>
  </script>
</body>
</html>
