<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9H97RK50TD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-9H97RK50TD');
  </script>

  <meta charset="UTF-8" />
  <title>Find popular places around you</title>

  <!-- CSS only; no 3rd-party JS to avoid "export" errors -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.2/css/bootstrap.min.css" />

  <style>
    body { background: #000; font-family: "Open Sans", sans-serif; }
    .searchTerm {
      width: 100%; border: 3px solid #00b4cc; padding: 5px; height: 60px;
      border-radius: 5px; outline: none; font-size: 20px;
    }
    #map { height: 260px; border-radius: 6px; }
    .image-parent { max-width: 190px; }
    .list-group { font-size: 18px; color: #000; }
    .hint { font-size: 12px; opacity: 0.75; }
    .btn-toggle .btn { cursor: pointer; }
    .notice { font-size: 12px; color: #ddd; margin: 6px 0 0; }

    /* Thicker slider */
    #distance-slider {
      -webkit-appearance: none; width: 100%; height: 16px; background: transparent; margin: 6px 0;
      cursor: pointer; touch-action: pan-y;
    }
    #distance-slider:focus { outline: none; }
    #distance-slider::-webkit-slider-runnable-track {
      height: 16px; background: #1b1b1b; border-radius: 10px; border: 1px solid #00b4cc;
    }
    #distance-slider::-webkit-slider-thumb {
      -webkit-appearance: none; margin-top: -6px; width: 28px; height: 28px; border-radius: 50%;
      background: #00b4cc; border: 2px solid #66e0ef; box-shadow: 0 0 0 3px rgba(0,180,204,0.15);
    }
    #distance-slider:active::-webkit-slider-thumb { transform: scale(1.05); }
    #distance-slider::-moz-range-track {
      height: 16px; background: #1b1b1b; border-radius: 10px; border: 1px solid #00b4cc;
    }
    #distance-slider::-moz-range-thumb {
      width: 28px; height: 28px; border-radius: 50%;
      background: #00b4cc; border: 2px solid #66e0ef; box-shadow: 0 0 0 3px rgba(0,180,204,0.15);
    }
    #distance-slider::-ms-track { height: 16px; background: transparent; border-color: transparent; color: transparent; }
    #distance-slider::-ms-fill-lower, #distance-slider::-ms-fill-upper {
      height: 16px; background: #1b1b1b; border: 1px solid #00b4cc; border-radius: 10px;
    }
    #distance-slider::-ms-thumb {
      width: 28px; height: 28px; border-radius: 50%; background: #00b4cc; border: 2px solid #66e0ef;
    }
  </style>
</head>

<body translate="no">
  <div class="container pt-3">
    <h1 class="text-warning text-center">Find popular places</h1>
    <h4 class="text-secondary text-center">Filter by distance and choose Top or New places.</h4>

    <input id="pac-input" class="searchTerm" placeholder="E.g. Cafes near Whitefield" autofocus />

    <!-- Sorting mode toggle -->
    <div class="mt-2 text-light btn-toggle" id="mode-container" role="group" aria-label="Sort mode">
      <button class="btn btn-sm btn-outline-info active" data-mode="top" title="Sort by number of ratings">Top places</button>
      <button class="btn btn-sm btn-outline-info" data-mode="new" title="Newest places first">New places</button>
      <div class="hint mt-1">Top = by number of ratings. New = earliest review date (shows “unknown” if none).</div>
    </div>

    <!-- Distance slider UI -->
    <div class="mt-2 text-light">
      <label for="distance-slider">Max distance: <span id="distance-value">5</span> km</label>
      <input type="range" id="distance-slider" min="1" max="50" value="5" step="1" />
      <div class="hint mt-1">Measured from your location (if allowed) or the current map center.</div>
      <div id="notice" class="notice"></div>
    </div>

    <!-- Map + Results -->
    <div class="mt-3">
      <div id="map" class="mb-3"></div>
      <div id="results" class="list-group"></div>
    </div>
  </div>

  <script>
    /* Quiet noisy extension error */
    window.addEventListener('unhandledrejection', (e) => {
      const msg = String((e && e.reason && e.reason.message) || e.reason || '');
      if (msg.includes('A listener indicated an asynchronous response')) e.preventDefault();
    });

    function geolocFail(){/* no-op */}
    function getValue(data, path){ for(let i=0;i<path.length && typeof data==="object";i++) data=data[path[i]]; return data; }

    // Distance helpers
    function haversineKm(a,b){ const toRad=d=>d*Math.PI/180;
      const lat1=a.lat(),lon1=a.lng(),lat2=b.lat(),lon2=b.lng(),R=6371;
      const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
      const s1=Math.sin(dLat/2)**2, s2=Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(s1+s2)); }
    function distanceMeters(origin, loc){
      if (window.google?.maps?.geometry?.spherical) return google.maps.geometry.spherical.computeDistanceBetween(origin, loc);
      return haversineKm(origin, loc)*1000;
    }

    // Age formatting
    function formatAge(tsMs){
      if (!tsMs || isNaN(tsMs)) return "unknown";
      const now=Date.now(); let diff=Math.max(0, now-tsMs);
      const day=86400000, year=365.25*day, month=30.44*day;
      const y=Math.floor(diff/year); diff-=y*year;
      const m=Math.floor(diff/month); diff-=m*month;
      const d=Math.floor(diff/day);
      if (y>=1) return `${y} yr${y>1?'s':''}${m?` ${m} mo`:''}`;
      if (m>=1) return `${m} mo${d?` ${d} d`:''}`;
      if (d>=1) return `${d} d`;
      const h=Math.floor(diff/3600000); if (h>=1) return `${h} hr${h>1?'s':''}`;
      const min=Math.floor(diff/60000); if (min>=1) return `${min} min`;
      return "today";
    }

    // Debounce helper
    function debounce(fn, wait=650){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); }; }

    // Globals
    let map, placesService, searchBox;
    let markers = [];
    let lastPlaces = [];
    let origin;
    const metaCache = new Map();   // place_id -> { score, tsMs, source, isOpen }
    const metaPending = new Map(); // place_id -> Promise<meta>
    let renderSeq = 0;             // avoid stale re-renders
    let searchSeq = 0;             // cancel stale pagination
    let userAdjustedSlider = false;

    function currentMode(){
      const active = document.querySelector('#mode-container .btn.active');
      return active?.dataset.mode || 'top';
    }
    function setModeButtons(mode){
      document.querySelectorAll('#mode-container .btn').forEach(btn=>{
        btn.classList.toggle('active', btn.dataset.mode===mode);
      });
    }

    // ---- Main init (after Maps JS loads) ----
    function initApp(){
      const resultsEl = document.getElementById("results");
      const input = document.getElementById("pac-input");
      const slider = document.getElementById("distance-slider");
      const distanceValue = document.getElementById("distance-value");
      const modeContainer = document.getElementById("mode-container");
      const noticeEl = document.getElementById("notice");

      map = new google.maps.Map(document.getElementById("map"), {
        center: { lat: -33.8688, lng: 151.2195 }, zoom: 15, mapTypeId: "roadmap"
      });
      placesService = new google.maps.places.PlacesService(map);
      searchBox = new google.maps.places.SearchBox(input); // suggestions only; we won't move the input
      origin = map.getCenter();

      // Visual distance circle
      const radiusCircle = new google.maps.Circle({
        map, center: origin, radius: parseFloat(slider.value)*1000,
        strokeColor: "#00b4cc", strokeOpacity: 0.8, strokeWeight: 1,
        fillColor: "#00b4cc", fillOpacity: 0.08, clickable: false
      });

      // Geolocation origin
      if (navigator.geolocation){
        const t = setTimeout(geolocFail, 10000);
        navigator.geolocation.getCurrentPosition(pos=>{
          clearTimeout(t);
          origin = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
          map.setCenter(origin);
          radiusCircle.setCenter(origin);
          if (lastPlaces.length) renderPlaces(lastPlaces, {resultsEl, slider, noticeEl});
        });
      }

      // Keep focus stable
      setTimeout(()=>{ input.focus(); input.select(); }, 0);
      google.maps.event.addListenerOnce(map, 'idle', ()=>{ input.focus(); input.select(); });

      // Bias text search to viewport
      map.addListener("bounds_changed", ()=> searchBox.setBounds(map.getBounds()));
      map.addListener("idle", ()=>{
        origin = map.getCenter();
        radiusCircle.setCenter(origin);
        if (lastPlaces.length) renderPlaces(lastPlaces, {resultsEl, slider, noticeEl});
      });

      // Distance slider
      const onDistanceChanged = ()=>{
        const km = parseFloat(slider.value);
        distanceValue.textContent = km;
        radiusCircle.setRadius(km*1000);
        userAdjustedSlider = true;
        if (lastPlaces.length) renderPlaces(lastPlaces, {resultsEl, slider, noticeEl});
      };
      distanceValue.textContent = slider.value;
      slider.addEventListener("input", onDistanceChanged);
      slider.addEventListener("change", onDistanceChanged);

      // Mode toggle
      modeContainer.addEventListener('click', (e)=>{
        const btn = e.target.closest('.btn[data-mode]');
        if (!btn) return;
        setModeButtons(btn.dataset.mode);
        if (lastPlaces.length) renderPlaces(lastPlaces, {resultsEl, slider, noticeEl});
      });

      // ---- TEXT SEARCH with pagination & robustness ----
      function runTextSearch(query){
        const q = (query||'').trim();
        if (!q) return;
        noticeEl.textContent = "";
        resultsEl.innerHTML = `<div class="list-group-item">Searching…</div>`;
        userAdjustedSlider = false; // new search = allow one auto expand if needed

        const mySearch = ++searchSeq;
        let aggregated = [];

        const request = { query: q, location: origin, radius: parseFloat(slider.value)*1000 };

        const handleBatch = (results, status, pagination) => {
          if (mySearch !== searchSeq) return; // stale
          if (status !== google.maps.places.PlacesServiceStatus.OK || !Array.isArray(results)) {
            if (aggregated.length === 0) resultsEl.innerHTML = `<div class="list-group-item">No results found.</div>`;
            return;
          }
          aggregated = aggregated.concat(results);

          // Try to fill missing geometry via details (rare)
          const noGeom = aggregated.filter(r => !r.geometry || !r.geometry.location);
          if (noGeom.length) {
            Promise.all(noGeom.slice(0,10).map(r => new Promise(res=>{
              placesService.getDetails({ placeId: r.place_id, fields: ['geometry'] }, (d, s)=>{
                if (s === google.maps.places.PlacesServiceStatus.OK && d?.geometry?.location){
                  r.geometry = { location: d.geometry.location, viewport: d.geometry.viewport };
                }
                res();
              });
            }))).then(()=> {
              lastPlaces = aggregated;
              renderPlaces(lastPlaces, {resultsEl, slider, noticeEl});
            });
          } else {
            lastPlaces = aggregated;
            renderPlaces(lastPlaces, {resultsEl, slider, noticeEl});
          }

          // keep paging up to ~60 results or until no next page
          if (pagination && pagination.hasNextPage && aggregated.length < 60) {
            // per docs, wait a bit before calling nextPage()
            setTimeout(()=> { if (mySearch === searchSeq) pagination.nextPage(); }, 300);
          }
        };

        placesService.textSearch(request, handleBatch);
      }

      // Enter triggers search
      input.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter'){
          e.preventDefault();
          runTextSearch(input.value);
        }
      });
      // As-you-type (debounced)
      input.addEventListener('input', debounce(()=> runTextSearch(input.value), 650));
      // Selecting a suggestion also triggers text search
      searchBox.addListener("places_changed", ()=> runTextSearch(input.value));
    }

    function clearMarkers(){ markers.forEach(m=>m.setMap(null)); markers = []; }

    // Combined meta fetch: earliest review + isOpen(); never rejects
    function getPlaceMeta(place){
      const pid = place.place_id;
      if (metaCache.has(pid)) return Promise.resolve(metaCache.get(pid));
      if (metaPending.has(pid)) return metaPending.get(pid);

      const p = new Promise((resolve)=>{
        try{
          placesService.getDetails(
            {
              placeId: pid,
              // opening_hours + utc_offset_minutes required for isOpen()
              fields: ['reviews','user_ratings_total','opening_hours','utc_offset_minutes']
            },
            (details, status)=>{
              let meta = { score: 0, tsMs: null, source: 'heuristic', isOpen: null };
              try{
                if (status === google.maps.places.PlacesServiceStatus.OK && details){
                  // Age from earliest review
                  if (Array.isArray(details.reviews) && details.reviews.length){
                    const times = details.reviews.map(r=> r?.time ? r.time*1000 : 0).filter(n=>n>0);
                    if (times.length){
                      const firstTsMs = Math.min(...times);
                      meta.score = firstTsMs;
                      meta.tsMs = firstTsMs;
                      meta.source = 'review';
                    }
                  }
                  // Current open status (supported method)
                  if (details.opening_hours && typeof details.opening_hours.isOpen === 'function'){
                    meta.isOpen = !!details.opening_hours.isOpen();
                  }
                }
                if (!meta.tsMs){
                  // no reviews -> unknown age; heuristic score for sorting only
                  meta.score = Date.now() - (place.user_ratings_total || 0)*86400000;
                }
              }catch(_){}
              metaCache.set(pid, meta); metaPending.delete(pid); resolve(meta);
            }
          );
        }catch(_){
          const meta = { score: Date.now(), tsMs: null, source: 'heuristic', isOpen: null };
          metaCache.set(pid, meta); metaPending.delete(pid); resolve(meta);
        }
      });
      metaPending.set(pid, p);
      return p;
    }

    function paintList(list, {resultsEl}){
      resultsEl.innerHTML = "";
      const frag = document.createDocumentFragment();

      list.forEach(place=>{
        if (!place.geometry || !place.geometry.location) return;

        const meters = distanceMeters(origin, place.geometry.location);
        const distKm = (meters/1000).toFixed(2);
        const pid = place.place_id;
        const meta = metaCache.get(pid);
        const ageText = meta && meta.tsMs ? formatAge(meta.tsMs) : "unknown";
        const sinceText = meta && meta.tsMs ? new Date(meta.tsMs).toLocaleDateString() : "";

        const a = document.createElement("a");
        a.className = "list-group-item list-group-item-action d-flex justify-content-between align-items-center";
        a.href = "https://www.google.com/maps/search/?api=1&query=" +
                 encodeURIComponent(place.formatted_address || place.name) +
                 "&query_place_id=" + place.place_id;

        a.innerHTML = `
          <div class="flex-column">
            <strong class="text-dark">${place.name}</strong>
            <span class="open-status" data-pid="${pid}"></span>
            <span class="badge badge-info badge-pill">${place.user_ratings_total || 0} ratings</span>
            <span class="badge badge-secondary badge-pill ml-2">${distKm} km</span>
            <span class="badge badge-light badge-pill ml-2">age: ${ageText}</span>
            ${ sinceText ? `<span class="badge badge-dark badge-pill ml-2">since ${sinceText}</span>` : "" }
          </div>
          <div class="image-parent">
            ${ place.photos && place.photos[0] ? `<img src="${place.photos[0].getUrl()}" class="img-fluid" alt="place">` : "" }
          </div>
        `;
        frag.appendChild(a);

        // Marker
        markers.push(new google.maps.Marker({ map, title: place.name, position: place.geometry.location }));

        // Open/closed label handling
        const statusEl = a.querySelector(`.open-status[data-pid="${pid}"]`);
        const setStatus = (m) => {
          if (!statusEl) return;
          if (typeof m?.isOpen === 'boolean') {
            statusEl.innerHTML = m.isOpen
              ? "<p class='text-primary mb-1'><small>Open now</small></p>"
              : "<p class='text-danger mb-1'><small>Closed</small></p>";
          } else {
            statusEl.innerHTML = "<p class='text-muted mb-1'><small>Hours: unknown</small></p>";
          }
        };
        if (meta) setStatus(meta);
        else {
          statusEl.innerHTML = "<p class='text-muted mb-1'><small>Checking hours…</small></p>";
          getPlaceMeta(place).then(setStatus);
        }
      });

      resultsEl.appendChild(frag);
    }

    // Smart origin + auto radius expand to avoid "no places" despite API results
    function smartOriginAndRadius(results, slider, noticeEl){
      if (!Array.isArray(results) || results.length === 0) return { changed: false };
      const locs = results.filter(r => r.geometry?.location).map(r => r.geometry.location);
      if (!locs.length) return { changed: false };

      const maxKm = parseFloat(slider.value);
      const farCount = locs.filter(loc => (distanceMeters(origin, loc)/1000) > maxKm).length;

      // If majority are outside radius, re-center to results centroid
      if (farCount === locs.length) {
        const avgLat = locs.reduce((s,l)=>s+l.lat(),0)/locs.length;
        const avgLng = locs.reduce((s,l)=>s+l.lng(),0)/locs.length;
        const centroid = new google.maps.LatLng(avgLat, avgLng);
        const distToOld = (distanceMeters(origin, centroid)/1000).toFixed(1);
        origin = centroid;
        map.setCenter(origin);
        noticeEl.textContent = `Auto-centered to results area (~${distToOld} km from previous center).`;
        return { changed: true, reason: 'recenter' };
      }
      return { changed: false };
    }

    async function renderPlaces(places, {resultsEl, slider, noticeEl}){
      const mySeq = ++renderSeq;

      resultsEl.innerHTML = "";
      clearMarkers();
      if (!places || !places.length) return;

      // If everything is out of range, try smart re-center once
      const originChange = smartOriginAndRadius(places, slider, noticeEl);

      const mode = currentMode();
      const maxKm = parseFloat(slider.value);

      let filtered = places.filter(p =>
        p.geometry && p.geometry.location &&
        distanceMeters(origin, p.geometry.location) <= maxKm*1000
      );

      // If still empty, gently auto-expand slider once (unless user already moved it)
      if (!filtered.length && !userAdjustedSlider) {
        const nearest = [...places]
          .filter(p => p.geometry?.location)
          .map(p => distanceMeters(origin, p.geometry.location)/1000)
          .sort((a,b)=>a-b)[0];
        if (isFinite(nearest)) {
          const newKm = Math.min(50, Math.max(maxKm, Math.ceil(nearest + 1)));
          slider.value = String(newKm);
          document.getElementById("distance-value").textContent = newKm;
          noticeEl.textContent = `Expanded distance to ${newKm} km to include closest result.`;
          userAdjustedSlider = true; // avoid repeated auto-expands
          if (mySeq !== renderSeq) return;
          // Recompute with new radius
          filtered = places.filter(p =>
            p.geometry && p.geometry.location &&
            distanceMeters(origin, p.geometry.location) <= newKm*1000
          );
        }
      }

      if (!filtered.length) {
        if (mySeq !== renderSeq) return;
        resultsEl.innerHTML = `<div class="list-group-item">No results within ${parseFloat(slider.value)} km.</div>`;
        return;
      }

      if (mode === "top"){
        filtered.sort((a,b) => (b.user_ratings_total || 0) - (a.user_ratings_total || 0));
      } else {
        const haveAllMetas = filtered.every(p => metaCache.has(p.place_id));
        if (haveAllMetas){
          filtered = filtered
            .map(p => ({ p, m: metaCache.get(p.place_id) }))
            .sort((a,b) => (b.m.score - a.m.score))
            .map(x => x.p);
        }
      }

      if (mySeq !== renderSeq) return;
      paintList(filtered, {resultsEl});

      if (mode === "new"){
        const toFetch = filtered.filter(p => !metaCache.has(p.place_id));
        if (toFetch.length){
          try{
            await Promise.all(toFetch.map(p => getPlaceMeta(p)));
            if (mySeq !== renderSeq) return;
            const resorted = filtered
              .map(p => ({ p, m: metaCache.get(p.place_id) }))
              .sort((a,b) => (b.m.score - a.m.score))
              .map(x => x.p);
            if (mySeq !== renderSeq) return;
            paintList(resorted, {resultsEl});
          }catch(err){
            console.warn('Details fetch error (ignored):', err);
          }
        }
      }
    }

    // Expose init after script loads
    window.initApp = initApp;
  </script>

  <!-- Google Maps API (geometry + places). We init on onload to avoid callback race. -->
  <script
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBCDJZDoS6NBc0JYuk11tx7v2kmIKR5I1I&libraries=places,geometry"
    async defer onload="initApp()" onerror="console.error('[gmaps] failed to load JS');">
  </script>
</body>
</html>
