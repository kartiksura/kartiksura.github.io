<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9H97RK50TD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-9H97RK50TD');
  </script>

  <meta charset="UTF-8" />
  <title>Find popular places around you</title>

  <link rel="apple-touch-icon" type="image/png" href="https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png" />
  <meta name="apple-mobile-web-app-title" content="CodePen" />
  <link rel="shortcut icon" type="image/x-icon" href="https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico" />
  <link rel="mask-icon" type="image/x-icon" href="https://cpwebassets.codepen.io/assets/favicon/logo-pin-8f3771b1072e3c38bd662872f6b673a722f4b3ca2421637d5596661b4e2132cc.svg" color="#111" />

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.2/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" />

  <style>
    #map { height: 10%; }
    #header { width: 100%; height: 300px; background: black; }
    body { background: #000; font-family: "Open Sans", sans-serif; }
    .image-parent { max-width: 190px; }
    .search { width: 100%; position: relative; display: flex; }
    .searchTerm {
      width: 100%; border: 3px solid #00b4cc; padding: 5px; height: 60px;
      border-radius: 5px; outline: none; font-size: 20px;
    }
    .list-group { width: 100%; font-size: 20px; color: #000; }
    .wrap { width: 80%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
    .hint { font-size: 12px; opacity: 0.75; }

    /* --- Thicker, easier-to-grab slider --- */
    #distance-slider {
      -webkit-appearance: none;
      width: 100%;
      height: 16px;                 /* thicker track */
      background: transparent;
      margin: 6px 0;
      cursor: pointer;
      touch-action: pan-y;
    }
    #distance-slider:focus { outline: none; }

    /* WebKit */
    #distance-slider::-webkit-slider-runnable-track {
      height: 16px;
      background: #1b1b1b;
      border-radius: 10px;
      border: 1px solid #00b4cc;
    }
    #distance-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      margin-top: -6px;             /* centers thumb on 16px track (thumb 28px) */
      width: 28px; height: 28px;    /* bigger thumb */
      border-radius: 50%;
      background: #00b4cc;
      border: 2px solid #66e0ef;
      box-shadow: 0 0 0 3px rgba(0,180,204,0.15);
    }
    #distance-slider:active::-webkit-slider-thumb {
      transform: scale(1.05);
    }

    /* Firefox */
    #distance-slider::-moz-range-track {
      height: 16px;
      background: #1b1b1b;
      border-radius: 10px;
      border: 1px solid #00b4cc;
    }
    #distance-slider::-moz-range-thumb {
      width: 28px; height: 28px;
      border-radius: 50%;
      background: #00b4cc;
      border: 2px solid #66e0ef;
      box-shadow: 0 0 0 3px rgba(0,180,204,0.15);
    }

    /* Old Edge / IE */
    #distance-slider::-ms-track {
      height: 16px;
      background: transparent;
      border-color: transparent;
      color: transparent;
    }
    #distance-slider::-ms-fill-lower,
    #distance-slider::-ms-fill-upper {
      height: 16px;
      background: #1b1b1b;
      border: 1px solid #00b4cc;
      border-radius: 10px;
    }
    #distance-slider::-ms-thumb {
      width: 28px; height: 28px;
      border-radius: 50%;
      background: #00b4cc;
      border: 2px solid #66e0ef;
      margin-top: 0;
    }
  </style>
</head>

<body translate="no">
  <h1 class="text-warning text-center">Find popular places</h1>
  <h4 class="text-secondary text-center">Powered by Google Maps. Filter by distance and choose Top or New places.</h4>

  <div id="header"></div>

  <div class="wrap">
    <div class="search"></div>
  </div>

  <div class="container">
    <!-- DEFAULT FOCUS -->
    <input id="pac-input" class="searchTerm" placeholder="E.g. Cafes near Whitefield" autofocus />

    <!-- Sorting mode toggle -->
    <div class="mt-2 text-light">
      <div class="btn-group btn-group-toggle" data-toggle="buttons" role="group" aria-label="Sort mode">
        <label class="btn btn-sm btn-outline-info active" id="mode-top-label" aria-pressed="true" title="Sort by number of ratings">
          <input type="radio" name="modeOptions" id="mode-top" autocomplete="off" checked> Top places
        </label>
        <label class="btn btn-sm btn-outline-info" id="mode-new-label" title="Newest places first">
          <input type="radio" name="modeOptions" id="mode-new" autocomplete="off"> New places
        </label>
      </div>
      <div class="hint mt-1">Top = sort by number of ratings. New = newest first (estimated via earliest review timestamp; fallback to ratings count).</div>
    </div>

    <!-- Distance slider UI -->
    <div class="mt-2 text-light">
      <label for="distance-slider">Max distance: <span id="distance-value">5</span> km</label>
      <input type="range" id="distance-slider" min="1" max="50" value="5" step="1" />
      <div class="hint mt-1">Distance is measured from your location (if allowed) or the current map center.</div>
    </div>

    <div class="list-group" id="ticketdiv">
      <div id="map"></div>
    </div>
  </div>

  <div class="footer">
    <p class="text-secondary text-center"></p>
    <p class="text-secondary text-center">There are bunch of alternative algorithms, maybe weight with number of 5 stars, etc.</p>
    <p class="text-center"><a href="https://forms.gle/HCXEhe5EnspUp5778">Click here to provide quick feedback, feature requests, and maybe a cool story</a></p>
  </div>

  <!-- Dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.4/popper.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"></script>

  <!-- App logic -->
  <script id="rendered-js">
    /**
     * @license
     * Copyright 2019 Google LLC.
     * SPDX-License-Identifier: Apache-2.0
     */
    // @ts-nocheck

    function geolocFail() { /* no-op */ }

    function getValue(data, path) {
      var i, len = path.length;
      for (i = 0; typeof data === "object" && i < len; ++i) data = data[path[i]];
      return data;
    }

    function initAutocomplete() {
      const listEl = document.getElementById("ticketdiv");
      const input = document.getElementById("pac-input");
      const slider = document.getElementById("distance-slider");
      const distanceValue = document.getElementById("distance-value");
      const modeTop = document.getElementById("mode-top");
      const modeNew = document.getElementById("mode-new");

      const map = new google.maps.Map(document.getElementById("map"), {
        center: { lat: -33.8688, lng: 151.2195 },
        zoom: 17,
        mapTypeId: "roadmap"
      });

      // ---- State ----
      let markers = [];
      let lastPlaces = [];
      let origin = map.getCenter(); // updated to geolocation if available
      let mode = "top"; // "top" | "new"
      const ageCache = new Map();        // place_id -> newnessScore
      const agePending = new Map();      // place_id -> Promise<number>
      const placesService = new google.maps.places.PlacesService(map);

      // Visualize the filter radius
      let radiusCircle = new google.maps.Circle({
        map,
        center: origin,
        radius: parseFloat(slider.value) * 1000,
        strokeColor: "#00b4cc",
        strokeOpacity: 0.8,
        strokeWeight: 1,
        fillColor: "#00b4cc",
        fillOpacity: 0.08,
        clickable: false
      });

      // Use geolocation as origin when available
      if (navigator.geolocation) {
        const location_timeout = setTimeout(geolocFail, 10000);
        navigator.geolocation.getCurrentPosition(function (position) {
          clearTimeout(location_timeout);
          const pos = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
          origin = pos;
          map.setCenter(pos);
          radiusCircle.setCenter(pos);
          // re-render from geolocated origin if we already have results
          if (lastPlaces.length) renderPlaces(lastPlaces);
        });
      }

      // Create the search box and link it to the UI element.
      const searchBox = new google.maps.places.SearchBox(input);
      map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);

      // Keep focus after Maps moves input into controls
      setTimeout(() => { input.focus(); input.select(); }, 0);
      google.maps.event.addListenerOnce(map, 'idle', () => {
        input.focus();
        input.select();
      });

      // Bias the SearchBox results towards current map's viewport.
      map.addListener("bounds_changed", () => {
        searchBox.setBounds(map.getBounds());
      });

      // Allow panning the map to redefine origin (on idle)
      map.addListener("idle", () => {
        origin = map.getCenter();
        radiusCircle.setCenter(origin);
        if (lastPlaces.length) renderPlaces(lastPlaces);
      });

      // Distance slider (live updates) — handle both 'input' (while dragging) and 'change' (after)
      const onDistanceChanged = () => {
        const km = parseFloat(slider.value);
        distanceValue.textContent = km;
        radiusCircle.setRadius(km * 1000);
        if (lastPlaces.length) renderPlaces(lastPlaces);
      };
      slider.addEventListener("input", onDistanceChanged);
      slider.addEventListener("change", onDistanceChanged);

      // Mode toggle — re-render immediately on change
      const onModeChanged = () => {
        mode = modeTop.checked ? "top" : "new";
        if (lastPlaces.length) renderPlaces(lastPlaces);
      };
      modeTop.addEventListener("change", onModeChanged);
      modeNew.addEventListener("change", onModeChanged);

      function clearMarkers() {
        markers.forEach(m => m.setMap(null));
        markers = [];
      }

      // Fetch/compute a "newness" score (bigger = newer) for a place.
      function getNewnessScore(place) {
        const pid = place.place_id;
        if (ageCache.has(pid)) return Promise.resolve(ageCache.get(pid));
        if (agePending.has(pid)) return agePending.get(pid);

        const p = new Promise((resolve) => {
          placesService.getDetails(
            { placeId: pid, fields: ['reviews', 'user_ratings_total'] },
            (details, status) => {
              let score;
              if (status === google.maps.places.PlacesServiceStatus.OK && details && Array.isArray(details.reviews) && details.reviews.length) {
                // use earliest review timestamp (ms) as "first seen" — higher = newer
                const firstTsMs = Math.min(...details.reviews.map(r => (r.time || 0) * 1000));
                score = firstTsMs || (Date.now() - (place.user_ratings_total || 0) * 86400000);
              } else {
                // fallback: fewer ratings ~ newer
                score = Date.now() - (place.user_ratings_total || 0) * 86400000;
              }
              ageCache.set(pid, score);
              agePending.delete(pid);
              resolve(score);
            }
          );
        });
        agePending.set(pid, p);
        return p;
      }

      async function renderPlaces(places) {
        listEl.innerHTML = "";
        clearMarkers();
        if (!places || places.length === 0) return;

        const maxKm = slider ? parseFloat(slider.value) : Infinity;

        // Filter with Google's spherical distance (meters) from origin
        let filtered = places.filter(p => {
          if (!p.geometry || !p.geometry.location) return false;
          const meters = google.maps.geometry.spherical.computeDistanceBetween(origin, p.geometry.location);
          return meters <= maxKm * 1000;
        });

        if (filtered.length === 0) {
          listEl.innerHTML = `<div class="list-group-item">No results within ${maxKm} km.</div>`;
          return;
        }

        // Sort based on mode
        if (mode === "top") {
          filtered.sort((a, b) => (b.user_ratings_total || 0) - (a.user_ratings_total || 0));
        } else {
          listEl.innerHTML = `<div class="list-group-item">Finding newest places…</div>`;
          const scores = await Promise.all(filtered.map(p => getNewnessScore(p)));
          filtered = filtered
            .map((p, i) => ({ p, s: scores[i] }))
            .sort((a, b) => (b.s - a.s)) // newer first
            .map(x => x.p);
          listEl.innerHTML = ""; // clear loading state
        }

        const bounds = new google.maps.LatLngBounds();

        filtered.forEach((place) => {
          if (!place.geometry || !place.geometry.location) return;

          const icon = {
            url: place.icon,
            size: new google.maps.Size(71, 71),
            origin: new google.maps.Point(0, 0),
            anchor: new google.maps.Point(17, 34),
            scaledSize: new google.maps.Size(25, 25)
          };

          const meters = google.maps.geometry.spherical.computeDistanceBetween(origin, place.geometry.location);
          const distKm = (meters / 1000).toFixed(2);

          const info = {
            name: place.name,
            photo: (place.photos && Array.isArray(place.photos)) ? place.photos[0].getUrl() : null,
            user_ratings_total: place.user_ratings_total,
            isOpen: getValue(place, ["opening_hours", "open_now"]),
            maps_link:
              "https://www.google.com/maps/search/?api=1&query=" +
              encodeURIComponent(place.formatted_address || place.name) +
              "&query_place_id=" + place.place_id,
            distance_km: distKm
          };

          listEl.innerHTML += `
            <a href="${info.maps_link}"
               class="list-group-item list-group-item-action d-flex justify-content-between align-items-center">
              <div class="flex-column">
                <strong class="text-dark">${info.name}</strong>
                ${
                  info.isOpen === true
                    ? "<p class='text-primary mb-1'><small>Open now</small></p>"
                    : "<p class='text-danger mb-1'><small>Closed</small></p>"
                }
                <span class="badge badge-info badge-pill">${info.user_ratings_total || 0} ratings</span>
                <span class="badge badge-secondary badge-pill ml-2">${info.distance_km} km</span>
                ${mode === "new" && ageCache.has(place.place_id)
                  ? `<span class="badge badge-light badge-pill ml-2">since ${new Date(ageCache.get(place.place_id)).toLocaleDateString()}</span>`
                  : ""
                }
              </div>
              <div class="image-parent">
                ${info.photo ? `<img src="${info.photo}" class="img-fluid" alt="place" />` : ""}
              </div>
            </a>`;

          // Marker
          markers.push(new google.maps.Marker({
            map,
            icon,
            title: place.name,
            position: place.geometry.location
          }));

          if (place.geometry.viewport) bounds.union(place.geometry.viewport);
          else bounds.extend(place.geometry.location);
        });

        // Optional strict fit:
        // map.fitBounds(bounds);
      }

      // When a place prediction is chosen, save and render it
      searchBox.addListener("places_changed", () => {
        const places = searchBox.getPlaces() || [];
        lastPlaces = Array.isArray(places) ? places : [];
        renderPlaces(lastPlaces);
      });
    }

    window.initAutocomplete = initAutocomplete;
  </script>

  <!-- Google Maps API (key unchanged) -->
  <!-- NOTE: include 'geometry' for precise distance calculations -->
  <script
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBCDJZDoS6NBc0JYuk11tx7v2kmIKR5I1I&callback=initAutocomplete&libraries=places,geometry&v=weekly"
    defer>
  </script>
</body>
</html>
