<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9H97RK50TD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-9H97RK50TD');
  </script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Find popular places around you</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.2/css/bootstrap.min.css" />

  <style>
    :root{
      --accent:#00b4cc;
      --accent-soft:#66e0ef;
      --bg:#000;
      --text:#fff;
      --muted:#ddd;
    }
    html,body{ height:100%; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: "Open Sans", system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      -webkit-text-size-adjust: 100%;
    }

    .app { padding-top: 12px; padding-bottom: 16px; }
    h1.text-warning{ font-size: clamp(1.25rem, 2.8vw, 1.8rem); }
    h4.text-secondary{ font-size: clamp(0.95rem, 2.2vw, 1.1rem); }

    /* Status bar */
    .statusbar{
      position: sticky; top: 0; z-index: 10;
      background:#111; color:#7ff; padding:6px 10px; font-size:12px;
      border-bottom:1px solid #0aa; display:none;
    }
    .statusbar.show{ display:block; }

    /* Search + button */
    .searchTerm {
      border: 3px solid var(--accent);
      padding: 8px 12px;
      height: 56px;
      outline: none;
      font-size: 18px;
      border-radius: 5px;
    }
    .input-group .searchTerm {
      width: auto; flex: 1 1 auto;
      border-top-right-radius: 0; border-bottom-right-radius: 0;
    }
    #go-btn {
      height: 56px; font-weight: 600; white-space: nowrap;
      border-top-left-radius: 0; border-bottom-left-radius: 0;
      border: 3px solid var(--accent); border-left: 0;
    }

    /* Sticky controls */
    .sticky-controls{
      position: sticky; top: 0; z-index: 3;
      background: linear-gradient(180deg, rgba(0,0,0,0.92), rgba(0,0,0,0.92));
      padding-top: 6px; padding-bottom: 8px;
    }

    .hint { font-size: 12px; opacity: 0.8; }
    .notice { font-size: 12px; color: var(--muted); margin: 6px 0 0; }
    .btn-toggle .btn { cursor: pointer; margin-right: 6px; margin-top: 6px; }

    #map { height: clamp(220px, 42vh, 420px); border-radius: 8px; }
    .list-group { font-size: 16px; color: #000; }
    .list-group-item strong { font-size: 16px; }
    .image-parent { max-width: 180px; }
    .image-parent img { border-radius: 6px; }

    /* Slider (touch-friendly) */
    #distance-slider {
      -webkit-appearance: none; width: 100%; height: 18px; background: transparent; margin: 6px 0;
      cursor: pointer; touch-action: pan-y;
    }
    #distance-slider:focus { outline: none; }
    #distance-slider::-webkit-slider-runnable-track {
      height: 18px; background: #1b1b1b; border-radius: 10px; border: 1px solid var(--accent);
    }
    #distance-slider::-webkit-slider-thumb {
      -webkit-appearance: none; margin-top: -6px; width: 30px; height: 30px; border-radius: 50%;
      background: var(--accent); border: 2px solid var(--accent-soft); box-shadow: 0 0 0 3px rgba(0,180,204,0.15);
    }
    #distance-slider:active::-webkit-slider-thumb { transform: scale(1.05); }

    /* InfoWindow readable on white */
    .iw { color: #111; }
    .iw .meta { color: #333; }
    .iw a { color: #0d6efd; text-decoration: none; }
    .iw a:hover { text-decoration: underline; }
    .gm-style .gm-style-iw-c, .gm-style .gm-style-iw-d { color: #111; }
    .iw .badge-light { color: #222; background-color: #f8f9fa; }

    /* Phones */
    @media (max-width: 576px){
      .app{ padding-left: 10px; padding-right: 10px; }
      .list-group-item{ padding: 10px 12px; }
      .list-group-item strong{ display:block; margin-bottom: 2px; }
      .image-parent{ max-width: 120px; }
      #go-btn{ height: 56px; padding-left: 14px; padding-right: 14px; }
      .btn-toggle .btn{ font-size: 14px; padding: 6px 10px; }
      #map{ height: clamp(220px, 48vh, 420px); }
    }
  </style>

  <script>
    window.addEventListener('unhandledrejection', (e) => {
      const msg = String((e && e.reason && e.reason.message) || e.reason || '');
      if (msg.includes('A listener indicated an asynchronous response')) e.preventDefault();
    });

    function setStatus(msg){
      const el = document.getElementById('statusbar');
      if (!el) return;
      el.textContent = msg;
      el.classList.add('show');
      console.log('[status]', msg);
    }

    function haversineKm(a,b){ const toRad=d=>d*Math.PI/180;
      const lat1=a.lat(),lon1=a.lng(),lat2=b.lat(),lon2=b.lng(),R=6371;
      const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
      const s1=Math.sin(dLat/2)**2, s2=Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(s1+s2)); }
    function distanceMeters(origin, loc){
      if (window.google?.maps?.geometry?.spherical) return google.maps.geometry.spherical.computeDistanceBetween(origin, loc);
      return haversineKm(origin, loc)*1000;
    }
    function formatAge(tsMs){
      if (!tsMs || isNaN(tsMs)) return "unknown";
      const now=Date.now(); let diff=Math.max(0, now-tsMs);
      const day=86400000, year=365.25*day, month=30.44*day;
      const y=Math.floor(diff/year); diff-=y*year;
      const m=Math.floor(diff/month); diff-=m*month;
      const d=Math.floor(diff/day);
      if (y>=1) return `${y} yr${y>1?'s':''}${m?` ${m} mo`:''}`;
      if (m>=1) return `${m} mo${d?` ${d} d`:''}`;
      if (d>=1) return `${d} d`;
      const h=Math.floor(diff/3600000); if (h>=1) return `${h} hr${h>1?'s':''}`;
      const min=Math.floor(diff/60000); if (min>=1) return `${min} min`;
      return "today";
    }
    function debounce(fn, wait=650){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); }; }

    // Heuristic review-rate estimator (local cohort)
    function percentile(arr, q) {
      if (!arr.length) return null;
      const i = (arr.length - 1) * q;
      const lo = Math.floor(i), hi = Math.ceil(i);
      if (lo === hi) return arr[lo];
      const h = i - lo;
      return arr[lo] * (1 - h) + arr[hi] * h;
    }
    function computeLocalRateStats(places) {
      const now = Date.now();
      const rates = [];
      places.forEach(p => {
        const meta = metaCache.get(p.place_id);
        const c = p.user_ratings_total || 0;
        const ts = meta?.tsMsUpper;
        if (c > 0 && ts && now > ts) {
          const days = (now - ts) / 86400000;
          if (days >= 1) rates.push(c / days); // reviews per day
        }
      });
      rates.sort((a,b)=>a-b);
      return {
        n: rates.length,
        p25: percentile(rates, 0.25),
        median: percentile(rates, 0.50),
        p75: percentile(rates, 0.75),
      };
    }

    // Globals
    let map, placesService, searchBox, infoWin;
    let markers = [];
    let lastPlaces = [];
    let origin;
    const metaCache = new Map();
    const metaPending = new Map();
    let renderSeq = 0;
    let searchSeq = 0;
    let userAdjustedSlider = false;

    function currentMode(){
      const active = document.querySelector('#mode-container .btn.active');
      return active?.dataset.mode || 'top';
    }
    function setModeButtons(mode){
      document.querySelectorAll('#mode-container .btn').forEach(btn=>{
        btn.classList.toggle('active', btn.dataset.mode===mode);
      });
    }

    function gmapsReady(){
      setStatus('Google Maps JS loaded');
      if (document.readyState === 'loading'){
        document.addEventListener('DOMContentLoaded', startApp);
      } else {
        startApp();
      }
    }
    window.gmapsReady = gmapsReady;

    window.addEventListener('load', ()=>{
      setTimeout(()=>{
        if (window.google && google.maps && google.maps.places && !map){
          setStatus('Fallback start (callback missed)');
          startApp();
        }
      }, 1500);
    });

    function startApp(){
      try{
        setStatus('Starting app…');
        if (!window.google || !google.maps || !google.maps.places){
          setStatus('❌ Google Maps not available. Check API key / network.');
          const resultsEl = document.getElementById("results");
          if (resultsEl) resultsEl.innerHTML = `<div class="list-group-item">Failed to initialize Google Maps. Check API key / network.</div>`;
          return;
        }

        const resultsEl = document.getElementById("results");
        const input = document.getElementById("pac-input");
        const goBtn = document.getElementById("go-btn");
        const slider = document.getElementById("distance-slider");
        const distanceValue = document.getElementById("distance-value");
        const modeContainer = document.getElementById("mode-container");
        const noticeEl = document.getElementById("notice");

        map = new google.maps.Map(document.getElementById("map"), {
          center: { lat: -33.8688, lng: 151.2195 }, zoom: 15, mapTypeId: "roadmap"
        });
        placesService = new google.maps.places.PlacesService(map);
        searchBox = new google.maps.places.SearchBox(input);
        infoWin = new google.maps.InfoWindow();
        origin = map.getCenter();

        const radiusCircle = new google.maps.Circle({
          map, center: origin, radius: parseFloat(slider.value)*1000,
          strokeColor: "#00b4cc", strokeOpacity: 0.8, strokeWeight: 1,
          fillColor: "#00b4cc", fillOpacity: 0.08, clickable: false
        });

        // Focus
        setTimeout(()=>{ input.focus(); input.select(); }, 0);
        google.maps.event.addListenerOnce(map, 'idle', ()=>{
          input.focus(); input.select();
          runSearch(input.value); // initial call
        });

        // Bias autocomplete
        map.addListener("bounds_changed", ()=> searchBox.setBounds(map.getBounds()));

        // Re-render for user pan/zoom
        let userPan = false, userZoom = false;
        map.addListener('dragstart', ()=>{ userPan = true; });
        map.addListener('zoom_changed', ()=>{ userZoom = true; });
        map.addListener('idle', ()=>{
          if (!(userPan || userZoom)) return;
          origin = map.getCenter();
          radiusCircle.setCenter(origin);
          userPan = false; userZoom = false;
          if (lastPlaces.length) renderPlaces(lastPlaces, {resultsEl, slider, noticeEl});
        });

        // Distance slider
        const onDistanceChanged = ()=>{
          const km = parseFloat(slider.value);
          distanceValue.textContent = km;
          radiusCircle.setRadius(km*1000);
          userAdjustedSlider = true;
          if (lastPlaces.length) renderPlaces(lastPlaces, {resultsEl, slider, noticeEl});
        };
        distanceValue.textContent = slider.value;
        slider.addEventListener("input", onDistanceChanged);
        slider.addEventListener("change", onDistanceChanged);

        // Mode toggle
        modeContainer.addEventListener('click', (e)=>{
          const btn = e.target.closest('.btn[data-mode]');
          if (!btn) return;
          setModeButtons(btn.dataset.mode);
          if (lastPlaces.length) renderPlaces(lastPlaces, {resultsEl, slider, noticeEl});
        });

        // Unified search
        function runSearch(queryRaw){
          const query = (queryRaw||'').trim();
          setStatus(query ? 'Searching (Text Search)…' : 'Searching nearby…');
          noticeEl.textContent = "";
          resultsEl.innerHTML = `<div class="list-group-item">Searching…</div>`;
          userAdjustedSlider = false;

          const mySearch = ++searchSeq;
          let aggregated = [];
          const radiusM = parseFloat(slider.value)*1000;

          const handleBatch = (results, status, pagination) => {
            if (mySearch !== searchSeq) return;
            if (status !== google.maps.places.PlacesServiceStatus.OK || !Array.isArray(results)) {
              if (aggregated.length === 0) {
                resultsEl.innerHTML = `<div class="list-group-item">No results found.</div>`;
                setStatus('No results (status: '+status+')');
              }
              return;
            }
            aggregated = aggregated.concat(results);

            const noGeom = aggregated.filter(r => !r.geometry || !r.geometry.location);
            const afterGeom = () => {
              lastPlaces = aggregated;
              setStatus('Rendering '+lastPlaces.length+' places');
              renderPlaces(lastPlaces, {resultsEl, slider, noticeEl});
            };

            if (noGeom.length) {
              Promise.all(noGeom.slice(0,10).map(r => new Promise(res=>{
                placesService.getDetails({ placeId: r.place_id, fields: ['geometry'] }, (d, s)=>{
                  if (s === google.maps.places.PlacesServiceStatus.OK && d?.geometry?.location){
                    r.geometry = { location: d.geometry.location, viewport: d.geometry.viewport };
                  }
                  res();
                });
              }))).then(afterGeom);
            } else { afterGeom(); }

            if (pagination && pagination.hasNextPage && aggregated.length < 60) {
              setTimeout(()=> { if (mySearch === searchSeq) pagination.nextPage(); }, 300);
            }
          };

          try {
            if (query) {
              const request = { query, location: origin, radius: radiusM };
              placesService.textSearch(request, handleBatch);
            } else {
              const request = { location: origin, radius: radiusM /*, type:'establishment'*/ };
              placesService.nearbySearch(request, handleBatch);
            }
          } catch (err) {
            console.error('[gmaps] search call failed:', err);
            resultsEl.innerHTML = `<div class="list-group-item">Search failed. See console.</div>`;
            setStatus('❌ Search threw an exception');
          }
        }

        // Expose for debugging
        window.__runSearch = runSearch;

        // Extra safety: call again shortly after load
        setTimeout(()=>{ if (!lastPlaces.length) runSearch(input.value); }, 1200);

        // Triggers
        const runSearchDebounced = debounce(()=> runSearch(input.value), 650);
        input.addEventListener('keydown', (e)=>{
          if (e.key === 'Enter'){
            e.preventDefault();
            runSearch(input.value);
          }
        });
        input.addEventListener('input', runSearchDebounced);
        searchBox.addListener("places_changed", ()=> runSearch(input.value));
        goBtn.addEventListener('click', ()=> runSearch(input.value));

        // Resize nudge
        window.addEventListener('resize', debounce(()=>{
          const c = map.getCenter();
          google.maps.event.trigger(map, 'resize');
          map.setCenter(c);
        }, 200));
      }catch(err){
        console.error(err);
        setStatus('❌ Fatal init error (see console)');
        const resultsEl = document.getElementById("results");
        if (resultsEl) resultsEl.innerHTML = `<div class="list-group-item">Init error. See console.</div>`;
      }
    }

    function clearMarkers(){ markers.forEach(m=>m.setMap(null)); markers = []; }

    // Details meta: earliest visible review (lower bound) + fields for heuristic
    function getPlaceMeta(place){
      const pid = place.place_id;
      if (metaCache.has(pid)) return Promise.resolve(metaCache.get(pid));
      if (metaPending.has(pid)) return metaPending.get(pid);

      const p = new Promise((resolve)=>{
        try{
          placesService.getDetails(
            { placeId: pid, fields: ['reviews','user_ratings_total','opening_hours'] },
            (details, status)=>{
              let meta = { 
                tsMsUpper: null,      // earliest review we can access (lower bound)
                ageEstDays: null,     // heuristic estimate (filled later)
                sinceEstTs: null,     // estimated "since"
                sortTs: null,         // for sorting in "new"
                source: 'heuristic',
                isOpen: null
              };

              try{
                if (status === google.maps.places.PlacesServiceStatus.OK && details){
                  if (Array.isArray(details.reviews) && details.reviews.length){
                    const times = details.reviews
                      .map(r => (r && typeof r.time === 'number') ? r.time*1000 : 0)
                      .filter(n => n > 0);
                    if (times.length){
                      meta.tsMsUpper = Math.min(...times);
                      meta.source = 'reviews<=5';
                    }
                  }
                  if (details.opening_hours && typeof details.opening_hours.isOpen === 'function'){
                    meta.isOpen = !!details.opening_hours.isOpen();
                  }
                }
              }catch(_){}

              meta.sortTs = meta.tsMsUpper || Date.now();
              metaCache.set(pid, meta); 
              metaPending.delete(pid); 
              resolve(meta);
            }
          );
        }catch(_){
          const meta = { tsMsUpper: null, ageEstDays: null, sinceEstTs: null, sortTs: Date.now(), source: 'heuristic', isOpen: null };
          metaCache.set(pid, meta); metaPending.delete(pid); resolve(meta);
        }
      });

      metaPending.set(pid, p);
      return p;
    }

    // InfoWindow HTML (includes age heuristic in "new" mode)
    function buildInfoHTML(place, meta){
      const mode = currentMode();
      const showAge = (mode === 'new');
      const m = meta ?? metaCache.get(place.place_id);

      const name = place.name || 'Place';
      const addr = place.formatted_address || place.vicinity || '';
      const rating = (typeof place.rating === 'number') ? place.rating.toFixed(1) : null;
      const count = place.user_ratings_total || 0;
      const meters = place.geometry?.location ? distanceMeters(origin, place.geometry.location) : null;
      const dist = meters != null ? `${(meters/1000).toFixed(2)} km` : '';
      const isOpen = (typeof m?.isOpen === 'boolean') ? m.isOpen : null;

      // Age badges
      const lbTs = m?.tsMsUpper || null;
      const estDays = m?.ageEstDays || null;
      const estTs = m?.sinceEstTs || null;
      const lbAge = lbTs ? formatAge(lbTs) : null;

      let ageBadge = '', sinceBadge = '';
      if (showAge){
        if (lbTs && estDays){
          ageBadge  = `<span class="badge badge-light">age: ≥ ${lbAge} (est. ~ ${formatAge(estTs)})</span>`;
          sinceBadge = `<span class="badge badge-dark">est since: ${new Date(estTs).toLocaleDateString()}</span>`;
        } else if (lbTs){
          ageBadge  = `<span class="badge badge-light">age: ≥ ${lbAge}</span>`;
          sinceBadge = `<span class="badge badge-dark">first review: ${new Date(lbTs).toLocaleDateString()}</span>`;
        } else if (estDays){
          ageBadge  = `<span class="badge badge-light">age: ~ ${formatAge(estTs)}</span>`;
          sinceBadge = `<span class="badge badge-dark">est since: ${new Date(estTs).toLocaleDateString()}</span>`;
        } else {
          ageBadge  = `<span class="badge badge-light">age: unknown</span>`;
        }
      }

      const pid = place.place_id;
      const lat = place.geometry?.location?.lat?.(); 
      const lng = place.geometry?.location?.lng?.();
      const mapsLink = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(addr || name)}&query_place_id=${pid}`;
      const dirLink = (lat && lng) ? `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_place_id=${pid}` : mapsLink;
      const photoUrl = place.photos && place.photos[0] && typeof place.photos[0].getUrl === 'function'
        ? place.photos[0].getUrl({maxWidth: 400})
        : null;

      return `
        <div class="iw">
          <h6>${name}</h6>
          <div class="meta">${addr || ''}</div>
          <div class="badges">
            ${ rating != null ? `<span class="badge badge-warning">★ ${rating}</span>` : '' }
            <span class="badge badge-info">${count} ratings</span>
            ${ dist ? `<span class="badge badge-secondary">${dist}</span>` : '' }
            ${
              isOpen === true ? `<span class="badge badge-success">Open now</span>` :
              isOpen === false ? `<span class="badge badge-danger">Closed</span>` :
              `<span class="badge badge-light">Hours: unknown</span>`
            }
            ${ ageBadge } ${ sinceBadge }
          </div>
          <div class="actions mt-2">
            <a href="${mapsLink}" target="_blank" rel="noopener">Open in Maps</a>
            <a href="${dirLink}" target="_blank" rel="noopener">Directions</a>
          </div>
          ${ photoUrl ? `<img class="thumb" src="${photoUrl}" alt="${name}">` : '' }
        </div>
      `;
    }

    function createMarker(place){
      const marker = new google.maps.Marker({ map, title: place.name, position: place.geometry.location });
      marker.addListener('click', async () => {
        let meta = metaCache.get(place.place_id);
        if (!meta) {
          if (!infoWin) infoWin = new google.maps.InfoWindow();
          infoWin.setContent(`<div class="iw"><h6>${place.name}</h6><div class="meta">Loading details…</div></div>`);
          infoWin.open(map, marker);
          try { meta = await getPlaceMeta(place); } catch(_) {}
        }
        infoWin.setContent(buildInfoHTML(place, metaCache.get(place.place_id)));
        infoWin.open(map, marker);
      });
      return marker;
    }

    function clearMarkers(){ markers.forEach(m=>m.setMap(null)); markers = []; }

    function paintList(list, {resultsEl}){
      resultsEl.innerHTML = "";
      clearMarkers();
      const frag = document.createDocumentFragment();
      const mode = currentMode();
      const showAge = (mode === 'new');

      list.forEach(place=>{
        if (!place.geometry || !place.geometry.location) return;

        const meters = distanceMeters(origin, place.geometry.location);
        const distKm = (meters/1000).toFixed(2);
        const pid = place.place_id;
        const meta = metaCache.get(pid);

        // Age badges
        const lbTs = meta?.tsMsUpper || null;
        const estDays = meta?.ageEstDays || null;
        const estTs = meta?.sinceEstTs || null;
        const lbAge = lbTs ? formatAge(lbTs) : null;

        let ageBadge = '', sinceBadge = '';
        if (showAge){
          if (lbTs && estDays){
            ageBadge  = `<span class="badge badge-light badge-pill ml-2">age: ≥ ${lbAge} (est. ~ ${formatAge(estTs)})</span>`;
            sinceBadge = `<span class="badge badge-dark badge-pill ml-2">est since: ${new Date(estTs).toLocaleDateString()}</span>`;
          } else if (lbTs){
            ageBadge  = `<span class="badge badge-light badge-pill ml-2">age: ≥ ${lbAge}</span>`;
            sinceBadge = `<span class="badge badge-dark badge-pill ml-2">first review: ${new Date(lbTs).toLocaleDateString()}</span>`;
          } else if (estDays){
            ageBadge  = `<span class="badge badge-light badge-pill ml-2">age: ~ ${formatAge(estTs)}</span>`;
            sinceBadge = `<span class="badge badge-dark badge-pill ml-2">est since: ${new Date(estTs).toLocaleDateString()}</span>`;
          } else {
            ageBadge  = `<span class="badge badge-light badge-pill ml-2">age: unknown</span>`;
          }
        }

        const a = document.createElement("a");
        a.className = "list-group-item list-group-item-action d-flex justify-content-between align-items-center";
        a.href = "https://www.google.com/maps/search/?api=1&query=" +
                 encodeURIComponent(place.formatted_address || place.name) +
                 "&query_place_id=" + place.place_id;

        a.innerHTML = `
          <div class="flex-column">
            <strong class="text-dark">${place.name}</strong>
            <span class="open-status" data-pid="${pid}"></span>
            <span class="badge badge-info badge-pill">${place.user_ratings_total || 0} ratings</span>
            <span class="badge badge-secondary badge-pill ml-2">${distKm} km</span>
            ${ showAge ? `${ageBadge} ${sinceBadge}` : "" }
          </div>
          <div class="image-parent">
            ${ place.photos && place.photos[0] ? `<img src="${place.photos[0].getUrl()}" class="img-fluid" alt="place">` : "" }
          </div>
        `;
        frag.appendChild(a);

        // Marker + InfoWindow
        markers.push(createMarker(place));

        // Open/closed (and allow meta to fill age badges if not present)
        const statusEl = a.querySelector(`.open-status[data-pid="${pid}"]`);
        const setStatusAndMaybeAge = (m) => {
          if (statusEl) {
            if (typeof m?.isOpen === 'boolean') {
              statusEl.innerHTML = m.isOpen
                ? "<p class='text-primary mb-1'><small>Open now</small></p>"
                : "<p class='text-danger mb-1'><small>Closed</small></p>";
            } else {
              statusEl.innerHTML = "<p class='text-muted mb-1'><small>Hours: unknown</small></p>";
            }
          }
        };

        if (meta) setStatusAndMaybeAge(meta);
        else {
          statusEl.innerHTML = "<p class='text-muted mb-1'><small>Checking hours…</small></p>";
          getPlaceMeta(place).then(setStatusAndMaybeAge);
        }
      });

      resultsEl.appendChild(frag);
      setStatus('Showing '+list.length+' places');
    }

    function smartOriginAndRadius(results, slider, noticeEl){
      if (!Array.isArray(results) || results.length === 0) return { changed: false };
      const locs = results.filter(r => r.geometry?.location).map(r => r.geometry.location);
      if (!locs.length) return { changed: false };

      const maxKm = parseFloat(slider.value);
      const allOutside = locs.every(loc => (distanceMeters(origin, loc)/1000) > maxKm);

      if (allOutside) {
        const avgLat = locs.reduce((s,l)=>s+l.lat(),0)/locs.length;
        const avgLng = locs.reduce((s,l)=>s+l.lng(),0)/locs.length;
        const centroid = new google.maps.LatLng(avgLat, avgLng);
        const distToOld = (distanceMeters(origin, centroid)/1000).toFixed(1);
        origin = centroid;
        map.setCenter(origin);
        noticeEl.textContent = `Auto-centered to results area (~${distToOld} km from previous center).`;
        return { changed: true, reason: 'recenter' };
      }
      return { changed: false };
    }

    async function renderPlaces(places, {resultsEl, slider, noticeEl}){
      const mySeq = ++renderSeq;

      resultsEl.innerHTML = "";
      clearMarkers();
      if (!places || !places.length) return;

      smartOriginAndRadius(places, slider, noticeEl);

      const mode = currentMode();
      const maxKm = parseFloat(slider.value);

      let filtered = places.filter(p =>
        p.geometry && p.geometry.location &&
        distanceMeters(origin, p.geometry.location) <= maxKm*1000
      );

      if (!filtered.length && !userAdjustedSlider) {
        const nearest = [...places]
          .filter(p => p.geometry?.location)
          .map(p => distanceMeters(origin, p.geometry.location)/1000)
          .sort((a,b)=>a-b)[0];
        if (isFinite(nearest)) {
          const newKm = Math.min(50, Math.max(maxKm, Math.ceil(nearest + 1)));
          slider.value = String(newKm);
          document.getElementById("distance-value").textContent = newKm;
          noticeEl.textContent = `Expanded distance to ${newKm} km to include the closest result.`;
          userAdjustedSlider = true;
          if (mySeq !== renderSeq) return;
          filtered = places.filter(p =>
            p.geometry && p.geometry.location &&
            distanceMeters(origin, p.geometry.location) <= newKm*1000
          );
        }
      }

      if (!filtered.length) {
        if (mySeq !== renderSeq) return;
        resultsEl.innerHTML = `<div class="list-group-item">No results within ${parseFloat(slider.value)} km.</div>`;
        setStatus('No filtered results');
        return;
      }

      if (mode === "top"){
        filtered.sort((a,b) => (b.user_ratings_total || 0) - (a.user_ratings_total || 0));
        if (mySeq !== renderSeq) return;
        paintList(filtered, {resultsEl});
        return;
      }

      // "NEW" MODE WITH HEURISTIC
      const toFetch = filtered.filter(p => !metaCache.has(p.place_id));
      if (toFetch.length){
        try { await Promise.all(toFetch.map(p => getPlaceMeta(p))); }
        catch(err){ console.warn('Details fetch error (ignored):', err); }
      }

      const stats = computeLocalRateStats(filtered);
      const now = Date.now();
      const day = 86400000;

      filtered.forEach(p => {
        const meta = metaCache.get(p.place_id) || {};
        const c = p.user_ratings_total || 0;
        const lbTs = meta.tsMsUpper || null;
        const lbDays = lbTs ? Math.max(1, (now - lbTs)/day) : 0;

        let estDays = null;
        if (stats.median && stats.median > 0 && c > 0){
          estDays = c / stats.median;
          estDays = Math.max(estDays, lbDays);
        }

        meta.ageEstDays = estDays;
        meta.sinceEstTs = estDays ? (now - estDays*day) : lbTs;
        meta.sortTs = meta.sinceEstTs || lbTs || now;
        metaCache.set(p.place_id, meta);
      });

      filtered = filtered
        .map(p => ({ p, m: metaCache.get(p.place_id) }))
        .sort((a,b) => (b.m.sortTs - a.m.sortTs))
        .map(x => x.p);

      if (mySeq !== renderSeq) return;
      paintList(filtered, {resultsEl});
    }
  </script>
</head>

<body>
  <div id="statusbar" class="statusbar">Loading…</div>

  <div class="container-fluid app">
    <h1 class="text-warning text-center">Find popular places</h1>
    <h4 class="text-secondary text-center">Filter by distance and choose Top or New places.</h4>

    <div class="sticky-controls">
      <!-- Input + Search -->
      <div class="input-group">
        <input id="pac-input" class="form-control searchTerm" placeholder="E.g. Cafes near Whitefield" autofocus />
        <div class="input-group-append">
          <button id="go-btn" class="btn btn-info" type="button">Search</button>
        </div>
      </div>

      <!-- Sorting mode toggle -->
      <div class="mt-2 text-light btn-toggle" id="mode-container" role="group" aria-label="Sort mode">
        <button class="btn btn-sm btn-outline-info active" data-mode="top" title="Sort by number of ratings">Top places</button>
        <button class="btn btn-sm btn-outline-info" data-mode="new" title="Newest places first">New places</button>
        <div class="hint mt-1">
          Top = by number of ratings. New = estimated from earliest visible review + local review rate;
          actual age may be older.
        </div>
      </div>

      <!-- Distance slider -->
      <div class="mt-2 text-light">
        <label for="distance-slider" class="mb-1">Max distance: <span id="distance-value">5</span> km</label>
        <input type="range" id="distance-slider" min="1" max="50" value="5" step="1" />
        <div class="hint mt-1">Measured from the current map center.</div>
        <div id="notice" class="notice"></div>
      </div>
    </div>

    <!-- Map + Results -->
    <div class="mt-3">
      <div id="map" class="mb-3"></div>
      <div id="results" class="list-group"></div>
    </div>
  </div>

  <!-- Google Maps API with your key -->
  <script
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBCDJZDoS6NBc0JYuk11tx7v2kmIKR5I1I&libraries=places,geometry&v=weekly&callback=gmapsReady"
    async defer
    onerror="var el=document.getElementById('results'); if(el){ el.innerHTML='<div class=&quot;list-group-item&quot;>Failed to load Google Maps JS (network/key).</div>'; }; document.getElementById('statusbar')?.classList.add('show'); document.getElementById('statusbar').textContent='❌ Failed to load Google Maps JS';">
  </script>
</body>
</html>
